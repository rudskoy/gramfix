name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Triggers on tags like v1.0, v1.1, v2.0
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.3) or tag (e.g., v1.3). Leave empty to use latest release.'
        required: false
        type: string
      signature:
        description: 'Sparkle ED signature (auto-filled from release if version provided)'
        required: false
        type: string
      size:
        description: 'DMG file size in bytes (auto-filled from release if version provided)'
        required: false
        type: string
      description:
        description: 'Release description (HTML, optional). Auto-filled from release notes if not provided.'
        required: false
        type: string

env:
  SCHEME: Gramfix
  PROJECT: Gramfix.xcodeproj

permissions:
  contents: write  # Required for creating releases and uploading assets

jobs:
  build:
    name: Build and Sign
    runs-on: macos-26  # macOS Tahoe with Xcode 26 (Liquid Glass support)
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
      dmg_name: ${{ steps.version.outputs.DMG_NAME }}
      signature: ${{ steps.sign.outputs.SIGNATURE }}
      size: ${{ steps.sign.outputs.SIZE }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: List available Xcode versions
        run: |
          echo "Available Xcode versions:"
          ls -la /Applications/ | grep Xcode
          echo ""
          echo "Current Xcode:"
          xcode-select -p
      
      - name: Select Xcode 26
        run: |
          # macOS 26 has Xcode 26.0 as default, but let's be explicit
          if [ -d "/Applications/Xcode_26.0.app" ]; then
            sudo xcode-select -s /Applications/Xcode_26.0.app/Contents/Developer
          elif [ -d "/Applications/Xcode.app" ]; then
            sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
          fi
      
      - name: Show Xcode version
        run: |
          xcodebuild -version
          echo ""
          echo "SDK versions:"
          xcodebuild -showsdks | head -20
      
      - name: Resolve Swift packages
        run: |
          xcodebuild -resolvePackageDependencies \
            -project $PROJECT \
            -scheme $SCHEME
      
      - name: Update version and copyright from git tag
        run: |
          VERSION="${GITHUB_REF_NAME#v}"  # Remove 'v' prefix: v1.2 -> 1.2
          YEAR=$(date +%Y)  # Get current year
          
          echo "Updating MARKETING_VERSION to $VERSION in project.pbxproj"
          echo "Updating copyright year to $YEAR in project.pbxproj"
          
          # Update MARKETING_VERSION in all build configurations
          sed -i '' "s/MARKETING_VERSION = [0-9.]*/MARKETING_VERSION = ${VERSION}/g" "$PROJECT/project.pbxproj"
          
          # Update copyright year in all build configurations
          sed -i '' "s/Copyright © [0-9]*/Copyright © ${YEAR}/g" "$PROJECT/project.pbxproj"
          
          # Verify the changes
          echo "Updated versions:"
          grep "MARKETING_VERSION = " "$PROJECT/project.pbxproj" | head -4
          echo ""
          echo "Updated copyright:"
          grep "INFOPLIST_KEY_NSHumanReadableCopyright" "$PROJECT/project.pbxproj" | head -2
      
      - name: Build Release
        run: |
          xcodebuild -project $PROJECT \
            -scheme $SCHEME \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            build 2>&1 | tee build.log
          
          # Check for build success
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Build failed. Last 100 lines of log:"
            tail -100 build.log
            exit 1
          fi
      
      - name: Verify app bundle
        run: |
          APP_PATH="build/DerivedData/Build/Products/Release/Gramfix.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App bundle not found at $APP_PATH"
            echo "Contents of build directory:"
            find build -name "*.app" 2>/dev/null || echo "No .app found"
            exit 1
          fi
          echo "App bundle found at $APP_PATH"
          ls -la "$APP_PATH"
      
      - name: Create DMG
        id: version
        run: |
          APP_PATH="build/DerivedData/Build/Products/Release/Gramfix.app"
          VERSION="${GITHUB_REF_NAME#v}"  # Remove 'v' prefix: v1.0 -> 1.0
          DMG_NAME="Gramfix-${VERSION}.dmg"
          
          # Create staging directory
          mkdir -p dmg_staging
          cp -R "$APP_PATH" dmg_staging/
          
          # Add Applications symlink for drag-install
          ln -s /Applications dmg_staging/Applications
          
          # Create DMG
          hdiutil create \
            -volname "Gramfix $VERSION" \
            -srcfolder dmg_staging \
            -ov \
            -format UDZO \
            "$DMG_NAME"
          
          echo "DMG_NAME=$DMG_NAME" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
      
      - name: Download Sparkle tools
        run: |
          SPARKLE_VERSION="2.6.4"
          curl -L -o sparkle.tar.xz \
            "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          mkdir -p sparkle
          tar -xf sparkle.tar.xz -C sparkle
      
      - name: Sign DMG with Sparkle
        id: sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          DMG_NAME="${{ steps.version.outputs.DMG_NAME }}"
          
          # Write private key to temp file (will be deleted after)
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_key
          
          # Sign the DMG and extract signature
          SIGN_OUTPUT=$(./sparkle/bin/sign_update "$DMG_NAME" --ed-key-file /tmp/sparkle_key)
          SIGNATURE=$(echo "$SIGN_OUTPUT" | grep -o 'sparkle:edSignature="[^"]*"' | sed 's/sparkle:edSignature="\([^"]*\)"/\1/')
          
          # Clean up private key immediately
          rm -f /tmp/sparkle_key
          
          # Get file size
          SIZE=$(stat -f%z "$DMG_NAME")
          
          echo "SIGNATURE=$SIGNATURE" >> $GITHUB_OUTPUT
          echo "SIZE=$SIZE" >> $GITHUB_OUTPUT
          
          echo "DMG signed successfully"
          echo "   Size: $SIZE bytes"
      
      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: gramfix-dmg
          path: ${{ steps.version.outputs.DMG_NAME }}
          retention-days: 7

  # ==========================================================================
  # Manual Approval Gate: Publish to rudskoy/gramfix
  # ==========================================================================
  # This job requires manual approval via the "production" environment.
  # Set up the environment in: Settings > Environments > New environment > "production"
  # Enable "Required reviewers" and add yourself.
  # ==========================================================================
  
  publish-to-releases:
    name: Publish to rudskoy/gramfix
    needs: build
    runs-on: ubuntu-latest
    environment: production  # Requires manual approval
    
    steps:
      - name: Download DMG artifact
        uses: actions/download-artifact@v4
        with:
          name: gramfix-dmg
      
      - name: Create Release on rudskoy/gramfix
        env:
          GH_TOKEN: ${{ secrets.RELEASES_PAT }}
          VERSION: ${{ needs.build.outputs.version }}
          DMG_NAME: ${{ needs.build.outputs.dmg_name }}
          SIGNATURE: ${{ needs.build.outputs.signature }}
          SIZE: ${{ needs.build.outputs.size }}
        run: |
          gh release create "v${VERSION}" \
            --repo rudskoy/gramfix \
            --title "Gramfix v${VERSION}" \
            --notes "## Gramfix v${VERSION}
          
          ### Download
          - **[Gramfix-${VERSION}.dmg](https://github.com/rudskoy/gramfix/releases/download/v${VERSION}/Gramfix-${VERSION}.dmg)**
          
          ### Installation
          1. Download the DMG
          2. Open it and drag Gramfix to Applications
          3. Right-click Gramfix → Open (first time only, to bypass Gatekeeper)
          
          ---
          
          ### For appcast.xml (copy this):
          \`\`\`xml
          <item>
            <title>Version ${VERSION}</title>
            <sparkle:version>${VERSION}</sparkle:version>
            <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
            <sparkle:minimumSystemVersion>15.0</sparkle:minimumSystemVersion>
            <enclosure 
              url=\"https://github.com/rudskoy/gramfix/releases/download/v${VERSION}/Gramfix-${VERSION}.dmg\"
              sparkle:edSignature=\"${SIGNATURE}\"
              length=\"${SIZE}\"
              type=\"application/octet-stream\"/>
          </item>
          \`\`\`" \
            "${DMG_NAME}"
          
          echo "Release created: https://github.com/rudskoy/gramfix/releases/tag/v${VERSION}"

  # ==========================================================================
  # Manual Appcast Update Job
  # ==========================================================================
  # This job can be manually triggered to update appcast.xml after a release
  # is built and published. Use the "Run workflow" button in GitHub Actions.
  # ==========================================================================
  
  update-appcast:
    name: Update Appcast
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Fetch release information
        id: release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_VERSION: ${{ inputs.version }}
          INPUT_SIGNATURE: ${{ inputs.signature }}
          INPUT_SIZE: ${{ inputs.size }}
          INPUT_DESCRIPTION: ${{ inputs.description }}
        run: |
          # If version is provided, use it; otherwise fetch latest
          if [ -z "$INPUT_VERSION" ] || [ "$INPUT_VERSION" = "" ]; then
            echo "No version provided, fetching latest release..."
            LATEST_TAG=$(gh release list --repo rudskoy/gramfix --limit 1 --json tagName --jq '.[0].tagName')
            TAG="$LATEST_TAG"
            VERSION=${LATEST_TAG#v}  # Remove 'v' prefix
            echo "Latest tag: $LATEST_TAG"
            echo "Latest version: $VERSION"
          else
            # Handle both tag format (v1.3) and version format (1.3)
            if [[ "$INPUT_VERSION" =~ ^v ]]; then
              TAG="$INPUT_VERSION"
              VERSION=${INPUT_VERSION#v}  # Remove 'v' prefix
              echo "Provided tag: $TAG"
              echo "Extracted version: $VERSION"
            else
              TAG="v${INPUT_VERSION}"  # Add 'v' prefix for tag
              VERSION="$INPUT_VERSION"
              echo "Provided version: $VERSION"
              echo "Using tag: $TAG"
            fi
          fi
          
          # Fetch release details using the tag
          RELEASE_INFO=$(gh release view "$TAG" --repo rudskoy/gramfix --json body,assets)
          
          # Extract signature and size from release body (from appcast XML snippet)
          SIGNATURE=$(echo "$RELEASE_INFO" | grep -o 'sparkle:edSignature="[^"]*"' | sed 's/sparkle:edSignature="\([^"]*\)"/\1/' || echo "")
          SIZE=$(echo "$RELEASE_INFO" | grep -o 'length="[^"]*"' | sed 's/length="\([^"]*\)"/\1/' || echo "")
          
          # If signature/size not in body, try to get from assets
          if [ -z "$SIZE" ]; then
            SIZE=$(echo "$RELEASE_INFO" | jq -r '.assets[0].size // empty')
          fi
          
          # Extract description from release body (remove the appcast XML snippet)
          DESCRIPTION=$(echo "$RELEASE_INFO" | jq -r '.body' | sed '/### For appcast.xml/,/```/d' | sed 's/```xml.*```//' | sed '/^$/d' || echo "")
          
          # Use provided inputs if available, otherwise use fetched values
          FINAL_VERSION="$VERSION"
          FINAL_SIGNATURE="${INPUT_SIGNATURE:-$SIGNATURE}"
          FINAL_SIZE="${INPUT_SIZE:-$SIZE}"
          FINAL_DESCRIPTION="${INPUT_DESCRIPTION:-$DESCRIPTION}"
          
          # Fallback to default description if still empty
          if [ -z "$FINAL_DESCRIPTION" ] || [ "$FINAL_DESCRIPTION" = "null" ] || [ "$FINAL_DESCRIPTION" = "" ]; then
            FINAL_DESCRIPTION="<h2>Version ${FINAL_VERSION}</h2>
          <ul>
            <li>Bug fixes and improvements</li>
          </ul>"
          fi
          
          echo "VERSION=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "SIGNATURE=$FINAL_SIGNATURE" >> $GITHUB_OUTPUT
          echo "SIZE=$FINAL_SIZE" >> $GITHUB_OUTPUT
          echo "DESCRIPTION<<EOF" >> $GITHUB_OUTPUT
          echo "$FINAL_DESCRIPTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Resolved values:"
          echo "  Version: $FINAL_VERSION"
          echo "  Signature: $FINAL_SIGNATURE"
          echo "  Size: $FINAL_SIZE"
          echo "  Description: (provided)"
      
      - name: Update appcast.xml
        env:
          VERSION: ${{ steps.release.outputs.VERSION }}
          SIGNATURE: ${{ steps.release.outputs.SIGNATURE }}
          SIZE: ${{ steps.release.outputs.SIZE }}
          DESCRIPTION: ${{ steps.release.outputs.DESCRIPTION }}
        run: |
          cat > update_appcast.py << 'PYTHON_SCRIPT'
          import sys
          from datetime import datetime
          import os
          
          version = os.environ['VERSION']
          signature = os.environ['SIGNATURE']
          size = os.environ['SIZE']
          description = os.environ.get('DESCRIPTION', '')
          
          # Generate current date in RFC 822 format
          pub_date = datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S +0000")
          
          # Use provided description or default
          if not description or description.strip() == "":
              description_content = "<h2>Version " + version + "</h2>\n          <ul>\n            <li>Bug fixes and improvements</li>\n          </ul>"
          else:
              # Replace {version} placeholder if present
              description_content = description.replace("{version}", version)
          
          # Create the new item XML
          new_item = "    <item>\n      <title>Version " + version + "</title>\n      <pubDate>" + pub_date + "</pubDate>\n      <sparkle:version>" + version + "</sparkle:version>\n      <sparkle:shortVersionString>" + version + "</sparkle:shortVersionString>\n      <sparkle:minimumSystemVersion>15.0</sparkle:minimumSystemVersion>\n      <description>\n        <![CDATA[\n          " + description_content + "\n        ]]>\n      </description>\n      <enclosure \n        url=\"https://github.com/rudskoy/gramfix/releases/download/v" + version + "/Gramfix-" + version + ".dmg\"\n        sparkle:edSignature=\"" + signature + "\"\n        length=\"" + size + "\"\n        type=\"application/octet-stream\"/>\n    </item>\n    \n"
          
          # Read the current appcast.xml
          with open('appcast.xml', 'r', encoding='utf-8') as f:
              lines = f.readlines()
          
          # Find where to insert (after the comment ends, before first <item>)
          insert_pos = None
          in_comment = False
          
          for i, line in enumerate(lines):
              if '<!--' in line:
                  in_comment = True
              if '-->' in line:
                  in_comment = False
                  # Look for the first <item> after the comment
                  for j in range(i + 1, len(lines)):
                      if '<item>' in lines[j]:
                          insert_pos = j
                          break
                  break
          
          if insert_pos is None:
              print("Error: Could not find insertion point in appcast.xml")
              sys.exit(1)
          
          # Insert the new item
          lines.insert(insert_pos, new_item)
          
          # Write back to file
          with open('appcast.xml', 'w', encoding='utf-8') as f:
              f.writelines(lines)
          
          print("Successfully added version " + version + " to appcast.xml")
          PYTHON_SCRIPT
          python3 update_appcast.py
      
      - name: Commit and push changes
        env:
          VERSION: ${{ steps.release.outputs.VERSION }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add appcast.xml
          git diff --staged --quiet || git commit -m "Update appcast.xml for version ${VERSION}"
          git push
